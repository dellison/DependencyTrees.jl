var documenterSearchIndex = {"docs":
[{"location":"#DependencyTrees.jl-1","page":"Home","title":"DependencyTrees.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"DependencyTrees.jl is a julia package for working with natural language dependency structures.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> ]add DependencyTrees\njulia> using DependencyTrees","category":"page"},{"location":"trees/#Trees-1","page":"Trees","title":"Trees","text":"","category":"section"},{"location":"trees/#","page":"Trees","title":"Trees","text":"Dependency structure in natural language consists of directed relations between words in a sentence.","category":"page"},{"location":"trees/#","page":"Trees","title":"Trees","text":"DependencyTree\nDependencyTrees.check_tree","category":"page"},{"location":"trees/#DependencyTrees.DependencyTree","page":"Trees","title":"DependencyTrees.DependencyTree","text":"DependencyTree\n\nA natural language sentence annotated with dependency structure.\n\n\n\n\n\n","category":"type"},{"location":"trees/#DependencyTrees.check_tree","page":"Trees","title":"DependencyTrees.check_tree","text":"check_tree(g, check_single_head=true, check_has_root=true, check_projective=false)\n\nEnsure the well-formedness of the dependency graph g, throwing an error if g is not well-formed.\n\n\n\n\n\n","category":"function"},{"location":"trees/#Types-of-tokens-1","page":"Trees","title":"Types of tokens","text":"","category":"section"},{"location":"trees/#","page":"Trees","title":"Trees","text":"UntypedDependency\nTypedDependency\nCoNLLU","category":"page"},{"location":"trees/#DependencyTrees.UntypedDependency","page":"Trees","title":"DependencyTrees.UntypedDependency","text":"UntypedDependency(id, form, head)\n\nRepresents a simple untyped (head –> dependent) relation between two words in a sentence.\n\n\n\n\n\n","category":"type"},{"location":"trees/#DependencyTrees.TypedDependency","page":"Trees","title":"DependencyTrees.TypedDependency","text":"TypedDependency(id, form, deprel, head)\n\nRepresents a typed (head -[deprel]-> dependent) relation between two words in a sentence. id is the index of the word form in the sentence (starting at 1, with 0 meaning the root node). deprel is the dependency relation between this word and its head).\n\n\n\n\n\n","category":"type"},{"location":"trees/#DependencyTrees.CoNLLU","page":"Trees","title":"DependencyTrees.CoNLLU","text":"CoNLLU\n\nCoNLLU token in a dependency tree.\n\nSee https://universaldependencies.org/format.html.\n\n\n\n\n\n","category":"type"},{"location":"treebanks/#Treebanks-1","page":"Treebanks","title":"Treebanks","text":"","category":"section"},{"location":"treebanks/#","page":"Treebanks","title":"Treebanks","text":"A treebank is a corpus of dependency-annotated sentences contained in one or more files on disk.","category":"page"},{"location":"treebanks/#","page":"Treebanks","title":"Treebanks","text":"Treebank","category":"page"},{"location":"treebanks/#DependencyTrees.Treebank","page":"Treebanks","title":"DependencyTrees.Treebank","text":"Treebank{T}(treebank; pattern=r\".\", add_ad=false, allow_nonprojective=false,kwargs...) whereT\n\nhi\n\n\n\n\n\nTreebank{T}(files; add_id=false, allow_nonprojective=false, kwargs...)\n\nhello\n\n\n\n\n\n","category":"type"},{"location":"oracles/#Oracles-1","page":"Oracles","title":"Oracles","text":"","category":"section"},{"location":"oracles/#","page":"Oracles","title":"Oracles","text":"In transition-based dependency parsing, oracles are used to map parser configurations (intermediate parser states) to gold transitions.","category":"page"},{"location":"oracles/#","page":"Oracles","title":"Oracles","text":"Static and dynamic oracles can both be used to iterate through trees.","category":"page"},{"location":"oracles/#","page":"Oracles","title":"Oracles","text":"julia> oracle = DynamicOracle(ArcEager())\njulia> for state in oracle(gold_tree)\n           # ...\n       end","category":"page"},{"location":"oracles/#","page":"Oracles","title":"Oracles","text":"state here will be a DependencyTrees.OracleState, which keeps track of the current configuration, possible transitions, and gold transitions.","category":"page"},{"location":"oracles/#","page":"Oracles","title":"Oracles","text":"DependencyTrees.OracleState","category":"page"},{"location":"oracles/#DependencyTrees.OracleState","page":"Oracles","title":"DependencyTrees.OracleState","text":"OracleState\n\nTemporary state for building a transition parse.\n\n\n\n\n\n","category":"type"},{"location":"oracles/#","page":"Oracles","title":"Oracles","text":"The iterator itself is something something","category":"page"},{"location":"oracles/#","page":"Oracles","title":"Oracles","text":"DependencyTrees.TreeOracle\nDependencyTrees.UnparsableTree","category":"page"},{"location":"oracles/#DependencyTrees.TreeOracle","page":"Oracles","title":"DependencyTrees.TreeOracle","text":"TreeOracle\n\nA gold tree for training.\n\nCollects an oracle, a gold tree, and an exploration policy.\n\n\n\n\n\n","category":"type"},{"location":"oracles/#DependencyTrees.UnparsableTree","page":"Oracles","title":"DependencyTrees.UnparsableTree","text":"UnparsableTree\n\nRepresents trees that an oracle can't parse.\n\n\n\n\n\n","category":"type"},{"location":"oracles/#","page":"Oracles","title":"Oracles","text":"Both kinds of oracles can build parse trees with labelled (typed) or unlabelled (untyped) dependency relations using the arc keyword argument.","category":"page"},{"location":"oracles/#","page":"Oracles","title":"Oracles","text":"untyped\ntyped","category":"page"},{"location":"oracles/#DependencyTrees.untyped","page":"Oracles","title":"DependencyTrees.untyped","text":"untyped(token)\n\nCreate an arc without a dependency label.\n\n\n\n\n\n","category":"function"},{"location":"oracles/#DependencyTrees.typed","page":"Oracles","title":"DependencyTrees.typed","text":"typed(token)\n\nCreate an arc with a labeled dependency relation.\n\n\n\n\n\n","category":"function"},{"location":"oracles/#Static-Oracles-1","page":"Oracles","title":"Static Oracles","text":"","category":"section"},{"location":"oracles/#","page":"Oracles","title":"Oracles","text":"StaticOracle","category":"page"},{"location":"oracles/#DependencyTrees.StaticOracle","page":"Oracles","title":"DependencyTrees.StaticOracle","text":"StaticOracle\n\nStatic (deterministic) oracle for mapping parser configurations to gold transitions.\n\n\n\n\n\n","category":"type"},{"location":"oracles/#Static-Oracle-Functions-1","page":"Oracles","title":"Static Oracle Functions","text":"","category":"section"},{"location":"oracles/#","page":"Oracles","title":"Oracles","text":"static_oracle\nstatic_oracle_prefer_shift","category":"page"},{"location":"oracles/#DependencyTrees.static_oracle","page":"Oracles","title":"DependencyTrees.static_oracle","text":"static_oracle(cfg, gold_tree)\n\nStatic oracle for arc-standard dependency parsing. Closes over gold trees, mapping parser configurations to optimal transitions.\n\n\n\n\n\nstatic_oracle(cfg, tree, transition)\n\nDefault static oracle function for arc-eager dependency parsing.\n\nSee Goldberg & Nivre 2012. (Also called Arc-Eager-Reduce in Qi & Manning 2017).\n\n\n\n\n\nstatic_oracle(::ArcHybrid, tree)\n\nStatic oracle for arc-hybrid dependency parsing. Closes over gold trees, mapping parser configurations to optimal transitions.\n\n\n\n\n\nstatic_oracle(::ArcSwiftConfig, graph)\n\nReturn a training oracle function which returns gold transition operations from a parser configuration with reference to graph.\n\nDescribed in Qi & Manning 2017.\n\n\n\n\n\nstatic_oracle(::ListBasedNonProjectiveConfig, tree)\n\nReturn a training oracle function which returns gold transition operations from a parser configuration with reference to graph.\n\n\n\n\n\n","category":"function"},{"location":"oracles/#DependencyTrees.static_oracle_prefer_shift","page":"Oracles","title":"DependencyTrees.static_oracle_prefer_shift","text":"static_oracle_prefer_shift(cfg, gold_tree, arc=untyped)\n\nStatic oracle for arc-eager dependency parsing. Similar to the \"regular\" static oracle, but always Shift when ambiguity is present.\n\nSee Qi & Manning 2017.\n\n\n\n\n\n","category":"function"},{"location":"oracles/#Dynamic-Oracles-1","page":"Oracles","title":"Dynamic Oracles","text":"","category":"section"},{"location":"oracles/#","page":"Oracles","title":"Oracles","text":"DynamicOracle","category":"page"},{"location":"oracles/#DependencyTrees.DynamicOracle","page":"Oracles","title":"DependencyTrees.DynamicOracle","text":"DynamicOracle(system, oracle_function = dynamic_oracle; arc = untyped)\n\nCreate a dynamic oracle for dependency parsing (see Goldberg & Nivre, 2012).\n\nDynamic oracles allow multiple gold transitions from each parser configuration.\n\n\n\n\n\n","category":"type"},{"location":"oracles/#Dynamic-Oracle-Functions-1","page":"Oracles","title":"Dynamic Oracle Functions","text":"","category":"section"},{"location":"oracles/#","page":"Oracles","title":"Oracles","text":"dynamic_oracle","category":"page"},{"location":"oracles/#DependencyTrees.dynamic_oracle","page":"Oracles","title":"DependencyTrees.dynamic_oracle","text":"dynamic_oracle(t, cfg::ArgEagerConfig, tree)\n\nDynamic oracle function for arc-eager parsing.\n\nFor details, see Goldberg & Nivre 2012.\n\n\n\n\n\ndynamic_oracle(t, cfg::ArgHybridConfig, tree)\n\nDynamic oracle function for arc-hybrid parsing.\n\nFor details, see Goldberg & Nivre, 2013.\n\n\n\n\n\n","category":"function"},{"location":"oracles/#Exploration-Policies-1","page":"Oracles","title":"Exploration Policies","text":"","category":"section"},{"location":"oracles/#","page":"Oracles","title":"Oracles","text":"Something about exploration during training.","category":"page"},{"location":"oracles/#","page":"Oracles","title":"Oracles","text":"AlwaysExplore\nNeverExplore\nExplorationPolicy","category":"page"},{"location":"oracles/#DependencyTrees.AlwaysExplore","page":"Oracles","title":"DependencyTrees.AlwaysExplore","text":"AlwaysExplore()\n\nPolicy for always exploring sub-optimal transitions.\n\n\n\n\n\n","category":"type"},{"location":"oracles/#DependencyTrees.NeverExplore","page":"Oracles","title":"DependencyTrees.NeverExplore","text":"NeverExplore()\n\nPolicy for never exploring sub-optimal transitions.\n\n\n\n\n\n","category":"type"},{"location":"oracles/#DependencyTrees.ExplorationPolicy","page":"Oracles","title":"DependencyTrees.ExplorationPolicy","text":"ExplorationPolicy(k, p)\n\nSimple exploration policy from Goldberg & Nivre, 2012. Returns true at rate p.\n\n\n\n\n\n","category":"type"},{"location":"transition_parsing/#","page":"Transition Systems","title":"Transition Systems","text":"Something here about transition parsing, I suppose.","category":"page"},{"location":"transition_parsing/#Transition-Systems-1","page":"Transition Systems","title":"Transition Systems","text":"","category":"section"},{"location":"transition_parsing/#Arc-Standard-1","page":"Transition Systems","title":"Arc-Standard","text":"","category":"section"},{"location":"transition_parsing/#","page":"Transition Systems","title":"Transition Systems","text":"ArcStandard","category":"page"},{"location":"transition_parsing/#DependencyTrees.ArcStandard","page":"Transition Systems","title":"DependencyTrees.ArcStandard","text":"ArcStandard()\n\nTransition system for for Arc-Standard dependency parsing.\n\nTransitions\n\nTransition Definition\nLeftArc(l) (σ|s1|s0, β, A) → (σ|s0, β, A ∪ (s0, l, s1))\nRightArc(l) (σ|s, b|β, A) → (σ, b|β, A ∪ (b, l, s))\nShift (σ,  b|β, A) → (σ|b, β, A)\n\nPreconditions\n\nTransition Condition\nLeftArc(l) ¬[s1 = 0], ¬∃k∃l'[(k, l', s1) ϵ A]\nRightArc(l) ¬∃k∃l'[(k, l', s0) ϵ A]\n\nSee Nivre 2004.\n\n\n\n\n\n","category":"type"},{"location":"transition_parsing/#","page":"Transition Systems","title":"Transition Systems","text":"Static oracle function:","category":"page"},{"location":"transition_parsing/#","page":"Transition Systems","title":"Transition Systems","text":"static_oracle(::DependencyTrees.ArcStandardConfig, tree, arc)","category":"page"},{"location":"transition_parsing/#DependencyTrees.static_oracle-Tuple{DependencyTrees.ArcStandardConfig,Any,Any}","page":"Transition Systems","title":"DependencyTrees.static_oracle","text":"static_oracle(cfg, gold_tree)\n\nStatic oracle for arc-standard dependency parsing. Closes over gold trees, mapping parser configurations to optimal transitions.\n\n\n\n\n\n","category":"method"},{"location":"transition_parsing/#Arc-Eager-1","page":"Transition Systems","title":"Arc-Eager","text":"","category":"section"},{"location":"transition_parsing/#","page":"Transition Systems","title":"Transition Systems","text":"ArcEager","category":"page"},{"location":"transition_parsing/#DependencyTrees.ArcEager","page":"Transition Systems","title":"DependencyTrees.ArcEager","text":"ArcEager()\n\nArc-Eager transition system for dependency parsing.\n\nTransitions\n\nTransition Definition\nLeftArc(l) (σ|s, b|β, A) → (σ, b|β, A ∪ (b, l, s))\nRightArc(l) (σ|s, b|β, A) → (σ, b|β, A ∪ (b, l, s))\nReduce (σ|s, β,  A) → (σ, β,   A)\nShift (σ,  b|β, A) → (σ|b, β, A)\n\nPreconditions\n\nTransition Condition\nLeftArc(l) ¬[s = 0], ¬∃k∃l'[(k, l', i) ϵ A]\nRightArc(l) ¬∃k∃l'[(k, l', j) ϵ A]\nReduce ∃k∃l[(k, l, i) ϵ A]\n\nReferences\n\nNivre 2003, Nivre 2008.\n\n\n\n\n\n","category":"type"},{"location":"transition_parsing/#Static-oracle-functions-1","page":"Transition Systems","title":"Static oracle functions","text":"","category":"section"},{"location":"transition_parsing/#","page":"Transition Systems","title":"Transition Systems","text":"static_oracle(::DependencyTrees.ArcEagerConfig, tree, arc)\nstatic_oracle_prefer_shift(::DependencyTrees.ArcEagerConfig, tree, arc)","category":"page"},{"location":"transition_parsing/#DependencyTrees.static_oracle-Tuple{DependencyTrees.ArcEagerConfig,Any,Any}","page":"Transition Systems","title":"DependencyTrees.static_oracle","text":"static_oracle(cfg, tree, transition)\n\nDefault static oracle function for arc-eager dependency parsing.\n\nSee Goldberg & Nivre 2012. (Also called Arc-Eager-Reduce in Qi & Manning 2017).\n\n\n\n\n\n","category":"method"},{"location":"transition_parsing/#DependencyTrees.static_oracle_prefer_shift-Tuple{DependencyTrees.ArcEagerConfig,Any,Any}","page":"Transition Systems","title":"DependencyTrees.static_oracle_prefer_shift","text":"static_oracle_prefer_shift(cfg, gold_tree, arc=untyped)\n\nStatic oracle for arc-eager dependency parsing. Similar to the \"regular\" static oracle, but always Shift when ambiguity is present.\n\nSee Qi & Manning 2017.\n\n\n\n\n\n","category":"method"},{"location":"transition_parsing/#Dynamic-oracle-functions-1","page":"Transition Systems","title":"Dynamic oracle functions","text":"","category":"section"},{"location":"transition_parsing/#","page":"Transition Systems","title":"Transition Systems","text":"dynamic_oracle(t, cfg::DependencyTrees.ArcEagerConfig, tree)","category":"page"},{"location":"transition_parsing/#DependencyTrees.dynamic_oracle-Tuple{Any,DependencyTrees.ArcEagerConfig,Any}","page":"Transition Systems","title":"DependencyTrees.dynamic_oracle","text":"dynamic_oracle(t, cfg::ArgEagerConfig, tree)\n\nDynamic oracle function for arc-eager parsing.\n\nFor details, see Goldberg & Nivre 2012.\n\n\n\n\n\n","category":"method"},{"location":"transition_parsing/#Arc-Hybrid-1","page":"Transition Systems","title":"Arc-Hybrid","text":"","category":"section"},{"location":"transition_parsing/#","page":"Transition Systems","title":"Transition Systems","text":"ArcHybrid","category":"page"},{"location":"transition_parsing/#DependencyTrees.ArcHybrid","page":"Transition Systems","title":"DependencyTrees.ArcHybrid","text":"ArcHybrid()\n\nArc-Hybrid system for transition dependency parsing.\n\nDescribed in Kuhlmann et al, 2011, Goldberg & Nivre, 2013.\n\n\n\n\n\n","category":"type"},{"location":"transition_parsing/#","page":"Transition Systems","title":"Transition Systems","text":"Static oracle function:","category":"page"},{"location":"transition_parsing/#","page":"Transition Systems","title":"Transition Systems","text":"static_oracle(::DependencyTrees.ArcHybridConfig, tree, arc)","category":"page"},{"location":"transition_parsing/#DependencyTrees.static_oracle-Tuple{DependencyTrees.ArcHybridConfig,Any,Any}","page":"Transition Systems","title":"DependencyTrees.static_oracle","text":"static_oracle(::ArcHybrid, tree)\n\nStatic oracle for arc-hybrid dependency parsing. Closes over gold trees, mapping parser configurations to optimal transitions.\n\n\n\n\n\n","category":"method"},{"location":"transition_parsing/#Dynamic-oracle-functions-2","page":"Transition Systems","title":"Dynamic oracle functions","text":"","category":"section"},{"location":"transition_parsing/#","page":"Transition Systems","title":"Transition Systems","text":"dynamic_oracle(t, cfg::DependencyTrees.ArcHybridConfig, tree)","category":"page"},{"location":"transition_parsing/#DependencyTrees.dynamic_oracle-Tuple{Any,DependencyTrees.ArcHybridConfig,Any}","page":"Transition Systems","title":"DependencyTrees.dynamic_oracle","text":"dynamic_oracle(t, cfg::ArgHybridConfig, tree)\n\nDynamic oracle function for arc-hybrid parsing.\n\nFor details, see Goldberg & Nivre, 2013.\n\n\n\n\n\n","category":"method"},{"location":"transition_parsing/#Arc-Swift-1","page":"Transition Systems","title":"Arc-Swift","text":"","category":"section"},{"location":"transition_parsing/#","page":"Transition Systems","title":"Transition Systems","text":"ArcSwift","category":"page"},{"location":"transition_parsing/#DependencyTrees.ArcSwift","page":"Transition Systems","title":"DependencyTrees.ArcSwift","text":"ArcSwift()\n\nParser configuration for arc-swift dependency parsing.\n\nDescribed in Qi & Manning 2017.\n\n\n\n\n\n","category":"type"},{"location":"transition_parsing/#","page":"Transition Systems","title":"Transition Systems","text":"Static oracle function:","category":"page"},{"location":"transition_parsing/#","page":"Transition Systems","title":"Transition Systems","text":"static_oracle(::DependencyTrees.ArcSwiftConfig, tree, arc)","category":"page"},{"location":"transition_parsing/#DependencyTrees.static_oracle-Tuple{DependencyTrees.ArcSwiftConfig,Any,Any}","page":"Transition Systems","title":"DependencyTrees.static_oracle","text":"static_oracle(::ArcSwiftConfig, graph)\n\nReturn a training oracle function which returns gold transition operations from a parser configuration with reference to graph.\n\nDescribed in Qi & Manning 2017.\n\n\n\n\n\n","category":"method"},{"location":"transition_parsing/#List-Based-Non-Projective-1","page":"Transition Systems","title":"List-Based Non-Projective","text":"","category":"section"},{"location":"transition_parsing/#","page":"Transition Systems","title":"Transition Systems","text":"ListBasedNonProjective","category":"page"},{"location":"transition_parsing/#DependencyTrees.ListBasedNonProjective","page":"Transition Systems","title":"DependencyTrees.ListBasedNonProjective","text":"ListBasedNonProjective()\n\nTransition system for list-based non-projective dependency parsing.\n\nDescribed in Nivre 2008, \"Algorithms for Deterministic Incremental Dependency Parsing.\"\n\n\n\n\n\n","category":"type"},{"location":"transition_parsing/#","page":"Transition Systems","title":"Transition Systems","text":"Static oracle function:","category":"page"},{"location":"transition_parsing/#","page":"Transition Systems","title":"Transition Systems","text":"static_oracle(::DependencyTrees.ListBasedNonProjectiveConfig, tree, arc)","category":"page"},{"location":"transition_parsing/#DependencyTrees.static_oracle-Tuple{DependencyTrees.ListBasedNonProjectiveConfig,Any,Any}","page":"Transition Systems","title":"DependencyTrees.static_oracle","text":"static_oracle(::ListBasedNonProjectiveConfig, tree)\n\nReturn a training oracle function which returns gold transition operations from a parser configuration with reference to graph.\n\n\n\n\n\n","category":"method"},{"location":"transition_parsing/#Misc.-1","page":"Transition Systems","title":"Misc.","text":"","category":"section"},{"location":"transition_parsing/#","page":"Transition Systems","title":"Transition Systems","text":"For stack-and-buffer transition systems (Arc-Eager, Arc-Standard, Arc-Hybrid, and Arc-Swift), DependencyTrees.jl implements functions for getting the tokens from the stack and buffer in a safe way:","category":"page"},{"location":"transition_parsing/#","page":"Transition Systems","title":"Transition Systems","text":"stacktoken\nbuffertoken","category":"page"},{"location":"transition_parsing/#DependencyTrees.stacktoken","page":"Transition Systems","title":"DependencyTrees.stacktoken","text":"stacktoken(cfg, i)\n\nReturn the token at stack index i (starting at 1).\n\n\n\n\n\n","category":"function"},{"location":"transition_parsing/#DependencyTrees.buffertoken","page":"Transition Systems","title":"DependencyTrees.buffertoken","text":"buffertoken(cfg, i)\n\nReturn the token at buffer index i (starting at 1).\n\n\n\n\n\n","category":"function"},{"location":"evaluation/#Evaluation-1","page":"Evaluation","title":"Evaluation","text":"","category":"section"},{"location":"evaluation/#","page":"Evaluation","title":"Evaluation","text":"labeled_accuracy\nunlabeled_accuracy","category":"page"},{"location":"evaluation/#DependencyTrees.labeled_accuracy","page":"Evaluation","title":"DependencyTrees.labeled_accuracy","text":"labeled_accuracy(prediction, gold)\n\nAccuracy score for dependency arcs, including the labels.\n\n\n\n\n\n","category":"function"},{"location":"evaluation/#DependencyTrees.unlabeled_accuracy","page":"Evaluation","title":"DependencyTrees.unlabeled_accuracy","text":"unlabeled_accuracy(prediction, gold)\n\nAccuracy score for dependency arcs, not including the labels.\n\n\n\n\n\n","category":"function"}]
}
